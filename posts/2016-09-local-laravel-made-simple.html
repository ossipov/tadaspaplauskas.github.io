<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Local Laravel made simple</title>
    <link href="/style.css" rel="stylesheet" type="text/css">
</head>
<body>

    <h1>Local Laravel made simple</h1>

    <p>
        <a href="/archive">Archive</a>
    </p>

    <p>
        2016
    </p>

<p name="8f1d" id="8f1d" class="graf graf--p graf-after--h3">The times of server software bundles on your dev machine are long behind us.</p><p name="2fa1" id="2fa1" class="graf graf--p graf-after--p">You‘re probably aware that back-end developers these days use virtualization tools such as Docker or Vagrant, mostly because “controlled environment”, “containerization” and “portability” are popular buzzwords these days.</p><p name="da67" id="da67" class="graf graf--p graf-after--p">While those are remarkable tools that do exactly what they promise, you might not always need them.</p><p name="7748" id="7748" class="graf graf--p graf-after--p">If you’re working on an application that only deals with native PHP API and does not rely on OS architecture or specific web server features, virtual environment might add more problems than it could solve. That’s especially true if you’re the only developer on the project.</p><p name="15cd" id="15cd" class="graf graf--p graf-after--p">Sometimes you just want to get going fast and crank out something that works ASAP. Or maybe you just want to check out some package. Waiting for a virtual machine to boot up can feel painfully slow when you’re getting in the flow.</p><h4 name="1d15" id="1d15" class="graf graf--h4 graf-after--p">What’s the alternative?</h4><p name="9407" id="9407" class="graf graf--p graf-after--h4">Here’s a good rule of thumb for development and life in general:</p><blockquote name="0a10" id="0a10" class="graf graf--blockquote graf-after--p">Everything should be made as simple as possible, but not simpler.</blockquote><p name="7ad6" id="7ad6" class="graf graf--p graf-after--blockquote">Pick the simplest tool that will do the job well and only move to something more complex when it isn’t enough anymore. Many people smarter than me have been preaching something along those lines for years: <a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it" data-href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">YAGNI</a>.</p><p name="abe6" id="abe6" class="graf graf--p graf-after--p">The truth is, to run most small-to-medium projects locally you probably only need PHP — it provides a built-in web server since version 5.4. It has many limits and should not be used outside of development environment, but nothing can beat it‘s simplicity.</p><p name="b9bf" id="b9bf" class="graf graf--p graf-after--p">You might already have PHP installed if you’re using composer locally. If not, <a href="http://php.net/manual/en/install.php" data-href="http://php.net/manual/en/install.php" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">install it</a> — that‘s the only dependency you’re gonna need.</p><h4 name="5873" id="5873" class="graf graf--h4 graf-after--p">What about a database?</h4><p name="250e" id="250e" class="graf graf--p graf-after--h4">SQLite is awesome — it works great, comes with PHP and can be used with Eloquent models.</p><p name="275a" id="275a" class="graf graf--p graf-after--p">Unless you need complex SQL features or rely on a specific DBMS behaviour, you should not notice much difference from MySQL, MariaDB or whatever you’re usually using.</p><p name="79c7" id="79c7" class="graf graf--p graf-after--p">You should be able to seamlessly transition from SQLite in development environment to other DBMS on staging and production servers.</p><p name="0128" id="0128" class="graf graf--p graf-after--p">Just make sure it is enabled in your php.ini file (it should be enabled by default, unless you are using Windows):</p><pre name="509f" id="509f" class="graf graf--pre graf-after--p">extension=php_sqlite3.dll</pre><p name="1b1d" id="1b1d" class="graf graf--p graf-after--pre">Now configure your .env file in Laravel project root folder:</p><pre name="7ebb" id="7ebb" class="graf graf--pre graf-after--p">DB_CONNECTION=sqlite<br>DB_DATABASE=full/path/to/file.sqlite</pre><p name="8451" id="8451" class="graf graf--p graf-after--pre">That’s it! It’s just a library that uses filesystem to store data, so no database servers will be running in the background.</p><p name="9438" id="9438" class="graf graf--p graf-after--p">You can put .sqlite file into /database folder in your Laravel application or anywhere else you find suitable.</p><h4 name="8f54" id="8f54" class="graf graf--h4 graf-after--p">Finishing up</h4><p name="498d" id="498d" class="graf graf--p graf-after--h4">Only one thing left to do. Open command line in your Laravel project root and run:</p><pre name="6232" id="6232" class="graf graf--pre graf-after--p">php artisan serve[ --host &quot;example.dev&quot; --port 80]</pre><p name="902e" id="902e" class="graf graf--p graf-after--pre">That’s it! Your development environment is live.</p><p name="b8a8" id="b8a8" class="graf graf--p graf-after--p">Do not forget to add host domain to your hosts file and point it to 127.0.0.1. If you do not specify host and port options, the default is localhost:8000.</p><p name="7297" id="7297" class="graf graf--p graf-after--p">Server will stay live as long as you keep the console open. You can run multiple servers at once — just choose different port numbers.</p><p name="7f71" id="7f71" class="graf graf--p graf-after--p">You can put artisan serve command into a bash (or npm) script so that you do not have to type out the hostname and port every time.</p><p name="276e" id="276e" class="graf graf--p graf-after--p">Run migrations, seeders and you’re ready to go!</p><p name="61f1" id="61f1" class="graf graf--p graf-after--p graf--trailing">And you can always move to a VM when this bare bones setup becomes too limiting.</p>

</body>
</html>
